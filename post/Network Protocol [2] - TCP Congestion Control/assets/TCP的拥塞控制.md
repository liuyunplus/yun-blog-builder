#### 1 背景

TCP协议是一种可靠的网络传输协议，为了保证数据传输的可靠性，发送方在检测到丢包的情况下会进行重传。这样就能够保证接收方收到的数据是完整的，整个过程是自动化的，一切看起来都是这么美好。但是，如果不进行任何控制，就会导致一个灾难性的后果。试想，一般出现了丢包的情况可能就意味着目前网络已经过载，也就是说网络已经出现了拥堵，此时如果仍然不断的尝试重传，无疑会进一步加重网络的负担，使得丢包变得更加频繁，然而这又进一步加剧了重传....，此时整个网络已经陷入恶性循环，最终走向瘫痪。

#### 2 基本思想

为了避免这种情况的发生，TCP协议使用了拥塞控制机制，目的是根据网络的拥塞状况动态的调整TCP发送端的发送速率。这样我们就能够让网络环境保持一种同时具有高吞吐量，低延时，低丢包率的平衡状态。在此之前的滑动窗口协议能够让发送方根据接收方回传的通知窗口(awnd)的值来调整自身窗口大小，以便发送速率能够跟上处理速率。现在我们要引入一个称为拥塞窗口(cwnd)的变量，该变量能够估算当前网络的最佳承载能力，并随着网络的拥塞程度而不断变化。此时发送方的实际窗口值(W)需要取这两者的较小值，用公式表示如下：
$$
W=min(cwnd，awnd)
$$

通知窗口可以通过返回的ACK头部信息获得，但是要如何才能获取拥塞窗口的值呢？我们可以考虑逐步的给网络施加压力，以此来探索网络中的最佳承载能力。刚开始时，拥塞窗口取一个较小值，随后每当收到一个连续的ACK就增加拥塞窗口的大小，如果出现丢包则表明很有可能网络此时已经拥塞，所以此时减少拥塞窗口的值，就这样拥塞窗口的值随着网络环境的变化而不断的被调整。与此同时，当通知窗口(awnd)足够大时，发送方的实际窗口大小就取值于拥塞窗口的大小，这也就使得发送速率随着网络环境而动态变化。

拥塞控制算法的前提是要判断出何时出现拥塞，最简单的是根据丢包情况来进行判别，复杂点的可以根据延时情况来判断，还可以让节点路由器配合告知拥塞情况，这种方法叫做显式拥塞通知，不过由于涉及全球大量路由器的更新，现在还不是很普及。本文就介绍几种常见的拥塞控制算法，对比不同算法间的区别，以此加深对TCP协议拥塞控制过程的理解。

#### 3 基于丢包的拥塞控制算法

##### 3.1 Tahoe算法

Tahoe算法主要包含了**慢启动**、**拥塞避免**和**快速重传**机制。在连接刚开始建立时会先执行慢启动过程，在这个过程中发送窗口(cwnd)随往返时间(RTT)呈指数型增长，直到发送窗口增长到大于慢启动阈值(ssthresh)，此后进入拥塞避免阶段，在 这个过程中发送窗口随往返时间(RTT)呈线性增长，不断的逼近网络临界点，此时一旦出现丢包情况，无论是超时重传或者是快速重传，发送窗口都会立马置为1，然后再次进入慢启动阶段。在整个传输过程中，慢启动和拥塞避免过程是在不断的切换的，以此达到动态控制发送窗口大小的目的。下图显示了随着时间的增长，发送窗口大小的变化。

##### 3.1.1 状态流转图

![](https://raw.githubusercontent.com/liuyunplus/yun-images/master/mbeD1u.png)

##### 3.1.2 慢启动阶段

整个慢启动过程概括如下：
(1) 设置cwnd的初始值为1，表示可以传一个MSS大小的数据。
(2) 每当收到一个ACK，$cwnd = cwnd + 1$，呈线性上升。
(3) 每当经过一个RTT，$cwnd = cwnd^2$，呈指数上升。
(4) 设置慢启动阈值(ssthresh)，当 $cwnd \geq ssthresh$ 时，进入拥塞避免阶段。

![TCP拥塞控制-慢启动](https://raw.githubusercontent.com/liuyunplus/yun-images/master/aqNu0f.svg)

##### 3.1.3 拥塞避免阶段

拥塞避免阶段如下：
(1) 每当收到一个ACK，$cwnd = cwnd + 1/cwnd$。
(2) 每当经过一个RTT，$cwnd = cwnd + 1$，呈线性上升。
(3) 若出现超时丢包，则 $sshthresh =  cwnd/2，cwnd重置为1$ ，进入慢启动阶段。

![TCP拥塞控制-拥塞避免](https://raw.githubusercontent.com/liuyunplus/yun-images/master/gbIClA.svg)

##### 3.1.4 拥塞窗口曲线图
![TCP拥塞控制-慢启动&拥塞避免](https://raw.githubusercontent.com/liuyunplus/yun-images/master/6H0B8U.svg)

##### 3.1.5 Problems

The problem with Tahoe is that it take a complete timeout interval to detect a packet loss and in fact, in most implementations it takes even longer because of the coarse grain timeout. Also since it dosen't send immediate ACK's, it sends cumulative acknowledgements, there fore it follows a 'go back n' approach. Thus every time a packet is lost it waits for a timeout and the pipeline is emptied. This offers a major cost in high band-width delay product links.

##### 3.2 Reno算法(标准算法)

从上面可以看出，Tahoe算法在快速重传时会将发送窗口设置为1并开始慢启动阶段。我们知道发生快速重传是因为收到3个重复的ACK导致的，而既然能收到重复ACK说明网络情况也没有那么糟糕，没必要像超时丢包那样反应那么激烈，这样的话网络的吞吐量会比较低。因此，Reno算法在Tahoe算法的基础上提出了快速恢复机制。

##### 3.2.1 状态流转图

![](https://raw.githubusercontent.com/liuyunplus/yun-images/master/62JyDh.png)

##### 3.2.2 快速恢复阶段
快速恢复阶段如下：
(1) 当收到一个重复的ACK时，$cwnd = cwnd + 1$，继续在快速恢复阶段。
(2) 当收到一个好的ACK时，$cwnd = sshthresh$，进入拥塞避免阶段。
(3) 若出现超时丢包，则 $sshthresh =  cwnd/2，cwnd重置为1$ ，进入慢启动阶段。

##### 3.2.3 拥塞窗口曲线图
![](https://raw.githubusercontent.com/liuyunplus/yun-images/master/ljEGn1.svg)
##### 3.2.4 Problems

Reno perform very well over TCP when the packet losses are small. But when we have multiple packet losses in one window then Reno doesn't perform too well and it's performance is almost the same as Tahoe under conditions of high packet loss. The reason is that it can only detect a single packet losses. If there is multiple packet drop then the first info about the packet loss comes when we receive the duplicate ACK's. But the information about the  second packet which was lost will come only after the ACK for the retransmitted first segment reaches the sender after one RTT.

Also it is possible that the CWD is reduced twice for packet losses which occurred in one window. Suppose we send packets 1,2,3,4,5,6,7,8,9 in that order. Suppose packets 1, and 2 are lost. The ACK's generated by 2,4,5 will cause the re-transmission of 1 and the CWD is reduced to 7. Then when we receive ACK for 6,7,8,9 our CWD is sufficiently large to allow to us to send 10,11. When the re-transmitted segment 1 reaches the receiver we get two more ACK's for 2(due to 10,11) so once again we enter fast-retransmit and re-transmit 2 and then enter fast recovery. Thus when we exit fast recovery for the second time our window size is set to 2. Thus we reduced our window size twice for packets lost in one window.

Another problem is that if the window is very small when the loss occurs then we would never receive enough duplicate acknowledgements for a fast-retransmit and we would have to wait for a coarse grained timeout . Thus is cannot effectively detect multiple packets losses.

##### 3.3 NewReno算法

NewReno is a slight modification over Reno. It is able to detect multiple packet losses and thus is much more efficient that Reno in the event of multiple packet losses.



TCP NewReno是对TCP Reno算法的一种改进。以下是其主要改进点：
1.  多级重传：在Reno算法中，只有在三次重传后才会重新启动拥塞避免，而NewReno在每一个拥塞窗口的缩小中都重新启动拥塞避免。
2.  快速恢复：在Reno算法中，数据包重传后慢启动会恢复到慢速恢复，而NewReno在快速恢复阶段中继续重传数据包以加速恢复。
3.  避免过早的拥塞避免：在Reno算法中，很容易发生过早的拥塞避免，而NewReno通过在缩小窗口时保留一定的窗口大小来避免过早的拥塞避免。
4.  改进的拥塞控制：NewReno改进了拥塞控制的策略，以更有效地避免拥塞并保证传输效率。
这些改进使得NewReno算法更加稳定，能够更好地适应网络环境的变化，并且具有更快的恢复能力。


##### 3.4 RHBP算法

优化快速重传机制



##### 3.5 BIC算法

在高速网络下能保证公平性

 

##### 3.6 CUBIC算法

对BIC算法的改进，改进了BIC某些情况下增长过快的不足。



#### 4 基于延迟的拥塞控制算法

##### 4.1 Vegas Algorithm

Vegas is a TCP implementation which is a modification of Reno. It builds on the fast that proactive measure to encounter congestion are much more efficient than reactive ones. It tried to get around the problem of coarse grain timeouts by suggesting an algorithm which checks for timeouts at a very efficient schedule. Also it overcomes the problem of requiring enough duplicate acknowledgements to detect a packet loss, and it also suggest a modified slow start algorithm which prevent it from congesting the network. It does not depend solely on packet loss as a sign of congestion. It detects congestion before the packet losses occur. However it still retains the other mechanism of Reno and Tahoe, and a packet loss can still be detected by the coarse grain timeout of the other mechanisms fail. The three major changes induced by Vegas are:

###### 4.1.1 New Re-Transmission Mechanism

###### 4.1.2 Congestion Avoidance

###### 4.1.3 Modified Slow-Start

##### 4.2 WestWood算法



##### 4.3 BBR Algorithm

