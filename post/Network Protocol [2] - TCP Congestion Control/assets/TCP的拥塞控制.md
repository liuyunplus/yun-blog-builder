#### 1 背景

TCP协议是一种可靠的网络传输协议，为了保证数据传输的可靠性，发送方在检测到丢包的情况下会进行重传。这样就能够保证接收方收到的数据是完整的，整个过程是自动化的，一切看起来都是这么美好。但是，如果不进行任何控制，就会导致一个灾难性的后果。试想，一般出现了丢包的情况可能就意味着目前网络已经过载，也就是说网络已经出现了拥堵，此时如果仍然不断的尝试重传，无疑会进一步加重网络的负担，使得丢包变得更加频繁，然而这又进一步加剧了重传....，此时整个网络已经陷入恶性循环，最终走向瘫痪。

#### 2 基本思想

为了避免这种情况的发生，TCP协议使用了拥塞控制机制，目的是根据网络的拥塞状况动态的调整TCP发送端的发送速率。这样我们就能够让网络环境保持一种同时具有高吞吐量，低延时，低丢包率的平衡状态。在此之前的滑动窗口协议能够让发送方根据接收方回传的通知窗口(awnd)的值来调整自身窗口大小，以便发送速率能够跟上处理速率。现在我们要引入一个称为拥塞窗口(cwnd)的变量，该变量能够估算当前网络的最佳承载能力，并随着网络的拥塞程度而不断变化。此时发送方的实际窗口值(W)需要取这两者的较小值，用公式表示如下：
$$
W=min(cwnd，awnd)
$$

通知窗口可以通过返回的ACK头部信息获得，但是要如何才能获取拥塞窗口的值呢？我们可以考虑逐步的给网络施加压力，以此来探索网络中的最佳承载能力。刚开始时，拥塞窗口取一个较小值，随后每当收到一个连续的ACK就增加拥塞窗口的大小，如果出现丢包则表明很有可能网络此时已经拥塞，所以此时减少拥塞窗口的值，就这样拥塞窗口的值随着网络环境的变化而不断的被调整。与此同时，当通知窗口(awnd)足够大时，发送方的实际窗口大小就取值于拥塞窗口的大小，这也就使得发送速率随着网络环境而动态变化。

拥塞控制算法的前提是要判断出何时出现拥塞，最简单的是根据丢包情况来进行判别，复杂点的可以根据延时情况来判断，还可以让节点路由器配合告知拥塞情况，这种方法叫做显式拥塞通知，不过由于涉及全球大量路由器的更新，现在还不是很普及。本文就介绍几种常见的拥塞控制算法，对比不同算法间的区别，以此加深对TCP协议拥塞控制过程的理解。

#### 3 基于丢包的拥塞控制算法

##### 3.1 Tahoe算法

Tahoe算法主要包含了**慢启动**、**拥塞避免**和**快速重传**机制。在连接刚开始建立时会先执行慢启动过程，在这个过程中发送窗口(cwnd)随往返时间(RTT)呈指数型增长，直到发送窗口增长到大于慢启动阈值(ssthresh)，此后进入拥塞避免阶段，在 这个过程中发送窗口随往返时间(RTT)呈线性增长，不断的逼近网络临界点，此时一旦出现丢包情况，无论是超时重传或者是快速重传，发送窗口都会立马置为1，然后再次进入慢启动阶段。在整个传输过程中，慢启动和拥塞避免过程是在不断的切换的，以此达到动态控制发送窗口大小的目的。下图显示了随着时间的增长，发送窗口大小的变化。

##### 3.1.1 状态流转图

![](https://raw.githubusercontent.com/liuyunplus/yun-images/master/mbeD1u.png)

##### 3.1.2 慢启动阶段

整个慢启动过程概括如下：
(1) 设置cwnd的初始值为1，表示可以传一个MSS大小的数据。
(2) 每当收到一个ACK，$cwnd = cwnd + 1$，呈线性上升。
(3) 每当经过一个RTT，$cwnd = cwnd^2$，呈指数上升。
(4) 设置慢启动阈值(ssthresh)，当 $cwnd \geq ssthresh$ 时，进入拥塞避免阶段。

![TCP拥塞控制-慢启动](https://raw.githubusercontent.com/liuyunplus/yun-images/master/aqNu0f.svg)

##### 3.1.3 拥塞避免阶段

拥塞避免阶段如下：
(1) 每当收到一个ACK，$cwnd = cwnd + 1/cwnd$。
(2) 每当经过一个RTT，$cwnd = cwnd + 1$，呈线性上升。
(3) 若出现超时丢包，则 $sshthresh =  cwnd/2，cwnd重置为1$ ，进入慢启动阶段。

![TCP拥塞控制-拥塞避免](https://raw.githubusercontent.com/liuyunplus/yun-images/master/gbIClA.svg)

##### 3.1.4 拥塞窗口曲线图
![TCP拥塞控制-慢启动&拥塞避免](https://raw.githubusercontent.com/liuyunplus/yun-images/master/6H0B8U.svg)


##### 3.2 Reno算法(标准算法)

从上面可以看出，Tahoe算法在快速重传时会将发送窗口设置为1并开始慢启动阶段。我们知道发生快速重传是因为收到3个重复的ACK导致的，而既然能收到重复ACK说明网络情况也没有那么糟糕，没必要像超时丢包那样反应那么激烈，这样的话网络的吞吐量会比较低。因此，Reno算法在Tahoe算法的基础上提出了快速恢复机制。

##### 3.2.1 状态流转图

![](https://raw.githubusercontent.com/liuyunplus/yun-images/master/62JyDh.png)

##### 3.2.2 快速恢复阶段
快速恢复阶段如下：
(1) 当收到一个重复的ACK时，$cwnd = cwnd + 1$，继续在快速恢复阶段。
(2) 当收到一个好的ACK时，$cwnd = sshthresh$，进入拥塞避免阶段。
(3) 若出现超时丢包，则 $sshthresh =  cwnd/2，cwnd重置为1$ ，进入慢启动阶段。

##### 3.2.3 拥塞窗口曲线图
![](https://raw.githubusercontent.com/liuyunplus/yun-images/master/ljEGn1.svg)
##### 3.2.4 Reno算法的问题

- 收到一个新的ACK就退出快速恢复阶段
- 对共享链路的其他RTT较大的连接不友好

##### 3.3 NewReno算法

TCP NewReno是对TCP Reno算法的一种改进。以下是其主要改进点：
1.  多级重传：在Reno算法中，只有在三次重传后才会重新启动拥塞避免，而NewReno在每一个拥塞窗口的缩小中都重新启动拥塞避免。
2.  快速恢复：在Reno算法中，数据包重传后慢启动会恢复到慢速恢复，而NewReno在快速恢复阶段中继续重传数据包以加速恢复。
3.  避免过早的拥塞避免：在Reno算法中，很容易发生过早的拥塞避免，而NewReno通过在缩小窗口时保留一定的窗口大小来避免过早的拥塞避免。
4.  改进的拥塞控制：NewReno改进了拥塞控制的策略，以更有效地避免拥塞并保证传输效率。
这些改进使得NewReno算法更加稳定，能够更好地适应网络环境的变化，并且具有更快的恢复能力。


##### 3.4 RHBP算法

优化快速重传机制



##### 3.5 BIC算法

在高速网络下能保证公平性

 

##### 3.6 CUBIC算法

对BIC算法的改进，改进了BIC某些情况下增长过快的不足。



#### 4 基于延迟的拥塞控制算法

##### 4.1 Vegas算法



##### 4.2 WestWood算法



##### 4.3 BBR算法

